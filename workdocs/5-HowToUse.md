# How to Use

This guide provides examples of how to use the main features of the `@decaf-ts/db-decorators` library.

## Repository

The `Repository` class is an abstract base class that implements the repository pattern.

### Creating a Repository

To create a repository, you need to extend the `Repository` class and implement the abstract CRUD methods.

```typescript
import { Repository, Model } from '@decaf-ts/db-decorators';
import { model, id, required } from '@decaf-ts/decorator-validation';

@model()
class User extends Model {
  @id()
  id: string;

  @required()
  name: string;
}

class UserRepository extends Repository<User, any> {
  constructor() {
    super(User);
  }

  async create(model: User): Promise<User> {
    // Implementation for creating a user
    return model;
  }

  async read(key: string): Promise<User> {
    // Implementation for reading a user
    return new User({ id: key, name: 'User' });
  }

  async update(model: User): Promise<User> {
    // Implementation for updating a user
    return model;
  }

  async delete(key: string): Promise<User> {
    // Implementation for deleting a user
    const model = await this.read(key);
    return model;
  }
}
```

### Operation Hooks

The `Repository` class provides `Prefix` and `Suffix` methods for each CRUD operation, allowing you to execute custom logic before and after the main operation.

```typescript
class UserRepository extends Repository<User, any> {
  // ...

  protected async createPrefix(model: User, ...args: any[]): Promise<[User, ...any[], any]> {
    console.log('Before creating user...');
    return [model, ...args];
  }

  protected async createSuffix(model: User, context: any): Promise<User> {
    console.log('After creating user...');
    return model;
  }
}
```

## Operation Decorators

Decorators like `@onCreate`, `@onUpdate`, `@onDelete`, and `@onRead` allow you to attach custom logic to specific repository operations.

```typescript
import { onCreate, onUpdate } from '@decaf-ts/db-decorators';

const logOnCreate = onCreate((context, data, key, model) => {
  console.log(`Creating model: ${model.constructor.name}`);
});

@model()
@logOnCreate
class Product extends Model {
  // ...
}
```

## Context

The `Context` class is used for passing contextual information through the different layers of your application.

```typescript
import { Context } from '@decaf-ts/db-decorators';

const context = new Context();
context.set('user', 'admin');

// You can then pass the context to repository methods
// userRepository.create(user, context);
```

## Additional Decorators

### `@id`

Marks a property as the primary key.

```typescript
@model()
class Product extends Model {
  @id()
  productId: string;
}
```

### `@generated`

Indicates that a property's value is generated by the database.

```typescript
@model()
class Order extends Model {
  @id()
  @generated()
  orderId: number;
}
```

### `@hash`

Automatically hashes a property's value.

```typescript
@model()
class User extends Model {
  @hash()
  password!: string;
}
```

### `@composed`

Composes a property's value from other properties.

```typescript
@model()
class Person extends Model {
  @composed(['firstName', 'lastName'], ' ')
  fullName: string;

  firstName: string;
  lastName: string;
}
```

### `@version`

Automatically manages a version number for optimistic locking.

```typescript
@model()
class Account extends Model {
  @version()
  version: number;
}
```
